设计模式（23种）
	单例设计模式
		目的：使得类只能创建一个实例
		方法
			饿汉式
				将构造函数的修饰改为private
				类中创建实例变量instance(实例化的别名)
				类中创建获取该对象的public方法
				注：调用时是能类调用，所以instance+获取该对象的方法都为static
				练习：TestSingleton.java
			懒汉式
				将构造函数的修饰改为private
				类中声明实例变量instance(实例化的别名)，不创建
				类中创建获取该对象的public方法，在其中判断声明中是否创建，如果没有创建一个新的实例
				注：调用时是能类调用，所以instance+获取该对象的方法都为static
				练习：TestSingleton1.java

理解main方法的语法
	向main方法中传值
		eclipse
			在要运行的程序中右键，点击“run as”，然后选择“run configurations”
			打开一个窗口，在左边选择自己要运行的.java文件，然后选择“Arguments”
			在”Program arguments“中输入向主函数传入的数组（用空格隔开，例如”小王 小明 小红 小绿“）
			然后选择“Apply”按钮，最后点击“Run”按钮，就可以实现向主函数传值得功能
		命令行
			javac+Java之后，直接输入向主函数传入的数值，例如“小王” “小明” “小红” "小绿"

		程序
			一个文件中创建两个类
			一个类中调用另一个类中的mian函数

类的成员之四：初始化快
	分类
		静态代码块
		非静态代码块（没有static修饰
		相同
			可以有输出语句
			可以对类的属性+类的声明进行初始化操作
			可以按照从上到下的顺序依次执行
		不同
			静态代码块
				不可以对非静态的属性（属性+方法）初始化
				静态代码块的执行要先于非静态代码块
				静态代码块只执行一次
			非静态代码块（没有static修饰）
				每一创建对象的时候都会执行一次，且先于构造器执行
		程序自己创建类中的属性方法
			左击“Source”
				创建接口
				生成getter和setter方法

				生成toString()方法
				生成hashCode()+equals()方法
				生成构造函数方法
		练习：TestOrder.java

final关键字
	final标记的类不能被继承
	final标记的方法不能被子类重写
	final变量（成员变量+局部变量）即成为常量，名称大写，且只能被赋值一次
		此常量在哪里赋值：①此常量不能使用默认初始化 ②可以显式的赋值、代码块、构造器。
	练习：TestFinal.java  Something.java

抽象类
	定义：将一个父类设计的非常抽象，以至于没有具体的实例，这样的类叫做抽象类
	abstract修饰类：抽象类
		不可实例化
		抽象类有构造器（废话）
		抽象方法所在的类一定是抽象类
		抽象类中可以没有抽象方法
	abstract修饰方法：抽象方法
		格式：没有方法体，包括{}，如breath方法
		只能保留方法的功能，而具体的执行，交给继承类的子类
			，由子类重写此抽象方法
		若子类继承抽象类，并重写所有的抽象方法，则此类是一个实体类，
			既可以实例化，如Student类
		若子类继承抽象类，没有重写所有的抽象方法，意味着此类中仍有抽象方法
			，则此类必须声明为抽象类，如Person类
	abstract 不能用来修饰属性、构造器、private、final、static
	练习：TestAbstract.java

模板方法设计模式
	定义：编写一个抽象父类，父类提供了多了子类的通用方法，并把一个或多个方法
		留给其子类实现，这就是一种模板模式。

接口(interface)
	来源：有时必须从几个派生类中生成一个子类，继承它们所有的属性和方法。
		但是Java 不支持多重继承。有了接口，就可以得到多重继承的效果
	组成：抽象方法+常量值定义的集合（不含变量+一般方法+构造器）
	实现接口类：class 类名 implements 接口{}
	特点：一个类可以实现多个接口，接口也可以继承其他接口（extends）
	练习：TestInterface.java
	总结
		通过接口可以实现不相关类的相同行为，而不需要考虑这些类之间的层次关系
		通过接口可以指明多个类需要实现的方法，一般用于对象的扩张功能
		接口主要用来定义规范，接触耦合关系

设计模式
	工厂方法（例题没有太明白）
		定义一个用于创建对象的接口，让子类决定实例化哪一个类
			，FactoryMethod使一个类的实例化延迟到其子类
		适用性
			当一个类不知道它必须创建的对象的类的时候
			当一个类希望由它的子类来指定它所创建的对象的时候
			当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望
				将哪一个帮助子类是代理者这一信息局部化的时候
		练习：TestFactoryMethod.java
	代理模式
		为其他对象提供一种代理以控制对这个对象的访问
		通过接口的方式，通过另外一个类B，去访问类A（体现接口的多态性，可以拿不同类的对象来使用）
		