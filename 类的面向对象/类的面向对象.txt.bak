4/10/2017（day2）
面向对象
	与面向过程的区别
		对象中加有封装+继承+多态
		把大象塞进冰箱
		过程：开门+把大象塞进冰箱+关门
		面向对象：对 象（人（打开冰箱+操作大象+关闭门）+大象（进入冰箱）+冰箱（开开+关闭门））
	类和类之间的关系
		关联关系（人+事物，人和食物有关系）
		继承关系（运动员-篮球运动员+足球运动员+棒球运动员）
		聚集关系（球队-队长+队员）
		组合（人-手+胳膊+腿）
	用途
		完成需求
		具有该所需的对象+如果不存在自己创建
	类中的含有
		属性：类的成员变量（field）
		行为：类的成员方法(methiod)

	落地法则
		设计类，并设计类的成员（成员变量&成员方法）
		通过类来创建类的对象（类的实例化）
		通过“对象.属相”或“对象.方法”来调用，完成相应的功能
		特点
			创建多个对象，彼此各自拥有一套类的属性，当对其中一个对象的属性进行修改时，不会影响到其他对象的属性值
			成员变量VS局部变量
				同
					遵循变量声明的格式：数据类型 变量名 [=初始值]
					都有对应的作用域
				不同
					声明的位置不同
						成员变量：类里+方法外
						局部变量：方法内，形参部分在代码块
					成员变量有修饰符
		类的方法：提供某种功能的实现
			实例格式： 权限修饰符 返回值类型 方法名（形参属性 形参名） {表达式}
				返回值类型：void：此方法不需要返回值
					有返回值的方法，在方法后的最后一定有return+返回值类型的对应变量
		
	以上概论：TeatClass.java
	练习：Person.java

	成员方法的重载
		同一个类名中方法名相同，形参的个数或者类型不同（顺序不同也算）
		注意：与重载方法的返回类型没有关系（也就是说返回值可以不同）
		练习：TestOverloading.java

	类对象作为形参+匿名类对象
		匿名类对象
			只需要调用一次类的对象时可用
			只能调用一次
		练习PassObject.java Circle.java

	可变个数的形参：String[] str(数组的形式)

	方法的参数传递
		形参：方法声明时，方法小括号的参数
		实参：调用方法时，实际传入的参数的值
		参数传递规则：值传递机制
			形参为基本数据类型：将实参的值传递给形参的基本数据类型的变量
			形参为引用数据类型：将实参的引用类型变量的值传递给形参的额引用数据类型变量
	
	特性：封装和隐藏
		当创建了一个类的对象之后，如果直接通过“对象.属性”的方式对相应的对象属性赋值的话
		，可能会出现不满足实际情况的意外，我们考虑不让对象来直接作用属性，而是使用“对象.方法”
		的形式来控制对象属性的访问，实际情况中，对属性的要求就可以通过方法来体现。
		解决方法：将类的属性私有化，提供公开的方法接口（set/get）来调用隐藏的属性

	特征：权限修饰符：用来修饰属性和方法
		缺省：类内部+同包
		public
		private
		protected
		权限由大到小：public-->protected-->缺省-->private
		对于类的修饰：public，default
	
	特征：构造器（构造方法）
		设计类时，若不显式声明类的构造器的话，程序会默认提供一个空参的构造器
		一定显式的定义类的类的构造器，那么默认的构造器就不再提供
		显式构造器声明格式：权限修饰符 类名（形参）{表达式}

	特想：this指针
		可以用来修饰属性+方法+构造器
		理解为当前对象或当前正在创建的对象，比如：this.name
		可以在构造器中通过“this.形参”的方式显式的调用本类中其他重载的构造器
		使用
			当形参与成员变量重名时，如果在方法内部需要使用成员变量，必须
			添加this表明该变量为成员变量
			在任意方法内，如果使用当前类的成员变量或者成员方法，可以在其
			前面添加this，增加程序的阅读性

	package
		声明源文件所在的包，写在程序的第一行
		每"."一次，表示一层文件目录
		包名都要小写
	import
		显式导入指定包下的类和接口
		写在包的声明和源文件之间
		如果需要引入多个类或接口，那么就并列写出
		如果导入的类时java.lang包下的，如System+Math等，则不需要显式声明
		import static 表示导入指定类的static的属性或方法
	
	继承
		通过“class A extends B”类实现类的继承
		当父类中似有属性或方法时，子类同样可以获取得到，只是由于封装性的设计
		，是的子类不可以直接调用罢了
		子类除了通过继承，获取父类的结构之外，还可以定义自己特有的成分。
		extends:子类是对父类功能的“扩展”，明确子类不是父类的子集
		java的继承只支持单继承，一个类只能继承一个父类，反之，一个父类可以有多个子类
		子类和父类是相对的概念
		方法的重写
			修饰符 返回值类型 方法名（参数列表）{表达式}
			子类继承父类后，若父类的方法对子类不适用，那么子类可以对父类的方法重写（overWrite）
			规则
				子类方法的“返回值类型 方法名（参数列表）”和父类的方法一样
				子类方法的修饰符不能小于父类方法的修饰符
				若父类方法抛异常，那么子类方法抛的异常不能大于父类
				子父类的方法必须同为static或同为非static
	练习：Kids.java ManKind.java

	super关键字
		可用于访问父类中的属性+成员方法（同名时，可以用来区分）
		可用于在子类构造方法中调用父类的构造器
		代表父类空间的标识
		1，当子类和父类中有同名的属性时，可以通过“supper。此属性”显式的调用父类中声明的属性
		若想调用调用子类中同名的属性“this.此属性”
		2，当子类重写父类的方法以后，在子类中若想再显式的调用父类的被重写的方法，就需要使用
		“super.方法名”
		3，super修饰构造器，通过在子类中使用“super（形参列表）”来显式的调用父类中指定的构造器
			在构造器内部，“super（形参列表）”必须声明在首行
			在构造器内部，“this(形参列表)”或“super(形参列表)”只能出现一个
			在构造器内部，不显式的调用“this(形参列表)”或“super(形参列表)”其中任何一个，默认调用的时父类空参的构造器
			建议：最好构造一个空参的构造器
		4.如果父类的构造器在类中被重写，那么继承该类的子类中重写构造器时必须要写继承父类的构造器，如果父类构造器有形参
			，子类在创建构造器时也需要为其加上（放在首行）
	练习：CheckAccount.java Account.java

	多态性
		中面向对象中最重要的概念，在Java中有两种体现
			方法的重载和重写
			对象对象的多态性
		子类对象的多态性的前提
			要有类的继承
			子类对父类方法的重写
		程序运行时分为编译状态和运行状态
			对于多态性来说，编译时看左边，将此引用变量理解为父类的类型
			运行时看右边，关注于真正对象的尸体，子类的对象，那么执行的方法就是子类重写的
	练习：Student2.java Person2.java Graduate.java TestInstance.java
